#!/usr/bin/env nu

export def parse-cli [
  --header: string
  --footer: string
  textconfig
  args
] {
  let types = ['string' 'int' 'float' 'filesize' 'duration' 'datetime']

  let name_re = '(?<name>[a-zA-Z0-9][a-zA-Z0-9-]*)'
  let long_re = '--' + $name_re
  let short_range_re = '[a-zA-Z0-9]'
  let short_re = '-(?<short>' + $short_range_re + ')'
  let shorts_re = '-(?<shorts>' + $short_range_re + '+)'
  let desc_re = '# (?<description>.+)'
  let pos_re = '(?<rest>\.\.\.)?' + $name_re

  let textconfig = $textconfig | append '--help # Print this help'
  let config_flags = $textconfig
    | each {
        parse -r (
          '^' + $long_re
            + '( \(' + $short_re + '\))?'
            + '(: (?<type>' + ($types | str join '|') + '))?'
            + '( ' + $desc_re + ')?$'
        )
      }
    | flatten
    | transpose key value
    | filter { $in.key | str starts-with 'capture' | not $in }
    | transpose -r

  let config_positionals = $textconfig
    | each { parse -r ('^' + $pos_re + '(' + $desc_re + ')?$') }
    | flatten
    | update rest { $in == '...' }
    | transpose key value
    | filter { $in.key | $in =~ '^capture\d+$' | not $in }
    | transpose -r
    | enumerate
    | rename -c { index: position }
    | flatten

  do {
    let rests = $config_positionals | where rest == true
    if (($rests | length) > 1) {
      error make {
        msg: $'Only one positional argument can be configured as "rest", but multiple were specified: (
          $rests | get name | str join ", "
        )'
      }
    }
  }

  if ('--help' in $args) {
    print_help
    exit
  }

  def print_help [] {
    if ($header | is-empty | not $in) {
      print -e $header
      print -en "\n"
    }

    # USAGE

    print -e $'(ansi green)Usage(ansi reset):'
    print -en $'  > ($env.PROCESS_PATH)'

    if ($config_flags | is-empty | not $in) {
      let shorts_without_values = $config_flags | filter { $in.type | is-empty } | get short | str join
      if ($shorts_without_values | is-empty | not $in) {
        print -en $' [-($shorts_without_values)]'
      }
      for $short_with_value in ($config_flags | filter { $in.type | is-empty | not $in }) {
        print -en $' [-($short_with_value.short) <value>]'
      }
    }

    for $pos in $config_positionals {
      if $pos.rest {
        print -en $' [($pos.name) ...]'
      } else if $pos.escaped {
        print -en $' -- [($pos.name) ...]'
      } else {
        print -en $' <($pos.name)>'
      }
    }

    print -en "\n"

    # FLAGS

    if ($config_flags | is-empty | not $in) {
      print -e $"\n(ansi green)Flags(ansi reset):"
      for $flag in $config_flags {
        let maybe_value = if ($flag.type | is-empty | not $in) {
          $' (ansi reset)<(ansi light_blue)($flag.type)(ansi reset)>'
        } else {
          ''
        }
        let maybe_short = if ($flag.short | is-empty | not $in) {
          $'(ansi reset),(ansi cyan) -($flag.short)'
        } else {
          ''
        }
        let maybe_desc = if ($flag.description | is-empty | not $in) { $'(ansi reset) - ($flag.description)' } else { '' }
        print -e $'  (ansi cyan)--($flag.name)($maybe_short)($maybe_value)($maybe_desc)'
      }
    }

    if ($footer | is-empty | not $in) {
      print -en "\n"
      print -e $footer
    }
  }

  #print -e ("flag config:\n" + ({ flags: $config_flags, positionals: $config_positionals } | table -ed 2))

  def config_by_short [short] {
    let found = $config_flags | where short == $short
    if ($found | is-empty) {
      error make { msg: ('unknown flag -' + $short) }
    }
    $found | first
  }
  def config_by_long [long] {
    let found = $config_flags | where name == $long
    if ($found | is-empty) {
      error make { msg: ('unknown flag --' + $long) }
    }
    $found | first
  }
  def config_by_position [pos, arg] {
    let pos = [$pos, (($config_positionals | length) - 1)] | math min
    let found = $config_positionals | where position == $pos
    if ($found | is-empty) {
      error make { msg: $'unknown positional argument #($pos + 1): ($arg)' }
    }
    $found | first
  }
  def handle_flag [flagconfig, value, pf] {
    if ($flagconfig.type? | is-empty | not $in) {
      if ($value | is-empty) {
        error make { msg: (
          'flag --' + $flagconfig.name
            + (if ($flagconfig.short | is-empty | not $in) { '/-' + $flagconfig.short })
            + ' requires a value'
        )}
      }
      return { eaten_value: true, newpf: ($pf | append { name: $flagconfig.name, value: $value }) }
    }

    return { eaten_value: false, newpf: ($pf | append { name: $flagconfig.name, value: true }) }
  }
  def handle_positional [flagconfig, arg, pp] {
    if ($flagconfig.name in $pp.name) {
      return (
        $pp | update value { |row|
          if ($row.name == $flagconfig.name) {
            $row.value | append $arg
          } else {
            $row.value
          }
        }
      )
    }
    return ($pp | append { name: $flagconfig.name, value: $arg })
  }

  mut parsed_flags = []
  mut parsed_positionals = []
  mut positional = 0
  mut args = $args

  if (($escaped_name | is-empty | not $in) and ('--' in $args)) {
    let split = $args | split list '--'
    $args = $split.0
    let escaped = $split.1
    $parsed_positionals = ($parsed_positionals | append { name: $escaped_name, value: $escaped })
  }

  mut i = 0
  let total = $args | length

  loop {
    if $i >= $total {
      break
    }
    let arg = $args | get $i
    $i = $i + 1
    let value = $args | get -i $i
    log $'Processing arg ($i - 1): ($arg)'

    let shorts = $arg | parse -r ('^' + $shorts_re + '$') | get shorts
    if ($shorts | is-empty | not $in) {
      let shorts = $shorts | first
      log $'  Processing shorts: ($shorts)'
      for $short in ($shorts | split chars) {
        log $'    Processing short: ($short)'
        let handled = handle_flag (config_by_short $short) $value $parsed_flags
        if ($handled.eaten_value) {
          $i = $i + 1
        }
        let newpf = $handled.newpf
        log $'      newpf is ($newpf)'
        $parsed_flags = $newpf
      }
      continue
    }

    let long = $arg | parse -r ('^' + $long_re + '$') | get name
    if ($long | is-empty | not $in) {
      let long = $long | first
      log $'  Processing long: ($long)'
      let handled = handle_flag (config_by_long $long) $value $parsed_flags
      if ($handled.eaten_value) {
        $i = $i + 1
      }
      let newpf = $handled.newpf
      log $'    newpf is ($newpf)'
      $parsed_flags = $newpf
      continue
    }

    log $'  Processing positional #($positional): ($arg)'
    let newpp = handle_positional (config_by_position $positional $arg) $arg $parsed_positionals
    $parsed_positionals = $newpp
    
    $positional = $positional + 1
  }

  { flags: $parsed_flags, pos: $parsed_positionals }
}

def log [...args] {
  if true {
    print -e ('- ' + ($args | str join ' '))
  }
}
